<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>CPEAnalyzer.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Dependency-Check Build-Reporting</a> &gt; <a href="../index.html" class="el_bundle">dependency-check-core</a> &gt; <a href="index.source.html" class="el_package">org.owasp.dependencycheck.analyzer</a> &gt; <span class="el_source">CPEAnalyzer.java</span></div><h1>CPEAnalyzer.java</h1><pre class="source lang-java linenums">/*
 * This file is part of dependency-check-core.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Copyright (c) 2012 Jeremy Long. All Rights Reserved.
 */
package org.owasp.dependencycheck.analyzer;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.concurrent.TimeUnit;
import org.apache.commons.lang3.builder.CompareToBuilder;
import org.apache.lucene.analysis.util.CharArraySet;
import org.apache.lucene.document.Document;
import org.apache.lucene.index.CorruptIndexException;
import org.apache.lucene.queryparser.classic.ParseException;
import org.apache.lucene.search.ScoreDoc;
import org.apache.lucene.search.TopDocs;
import org.owasp.dependencycheck.Engine;
import org.owasp.dependencycheck.analyzer.exception.AnalysisException;
import org.owasp.dependencycheck.data.cpe.CpeMemoryIndex;
import org.owasp.dependencycheck.data.cpe.Fields;
import org.owasp.dependencycheck.data.cpe.IndexEntry;
import org.owasp.dependencycheck.data.cpe.IndexException;
import org.owasp.dependencycheck.data.lucene.LuceneUtils;
import org.owasp.dependencycheck.data.lucene.SearchFieldAnalyzer;
import org.owasp.dependencycheck.data.nvdcve.CveDB;
import org.owasp.dependencycheck.data.nvdcve.DatabaseException;
import org.owasp.dependencycheck.dependency.Confidence;
import org.owasp.dependencycheck.dependency.Dependency;
import org.owasp.dependencycheck.dependency.Evidence;
import org.owasp.dependencycheck.dependency.EvidenceCollection;
import org.owasp.dependencycheck.dependency.Identifier;
import org.owasp.dependencycheck.dependency.VulnerableSoftware;
import org.owasp.dependencycheck.exception.InitializationException;
import org.owasp.dependencycheck.utils.DependencyVersion;
import org.owasp.dependencycheck.utils.DependencyVersionUtil;
import org.owasp.dependencycheck.utils.Settings;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * CPEAnalyzer is a utility class that takes a project dependency and attempts
 * to discern if there is an associated CPE. It uses the evidence contained
 * within the dependency to search the Lucene index.
 *
 * @author Jeremy Long
 */
<span class="fc" id="L66">public class CPEAnalyzer extends AbstractAnalyzer {</span>

    /**
     * The Logger.
     */
<span class="fc" id="L71">    private static final Logger LOGGER = LoggerFactory.getLogger(CPEAnalyzer.class);</span>
    /**
     * The maximum number of query results to return.
     */
    private static final int MAX_QUERY_RESULTS = 25;
    /**
     * The weighting boost to give terms when constructing the Lucene query.
     */
    private static final String WEIGHTING_BOOST = &quot;^5&quot;;
    /**
     * A string representation of a regular expression defining characters
     * utilized within the CPE Names.
     */
    private static final String CLEANSE_CHARACTER_RX = &quot;[^A-Za-z0-9 ._-]&quot;;
    /**
     * A string representation of a regular expression used to remove all but
     * alpha characters.
     */
    private static final String CLEANSE_NONALPHA_RX = &quot;[^A-Za-z]*&quot;;
    /**
     * The additional size to add to a new StringBuilder to account for extra
     * data that will be written into the string.
     */
    private static final int STRING_BUILDER_BUFFER = 20;
    /**
     * The CPE in memory index.
     */
    private CpeMemoryIndex cpe;
    /**
     * The CVE Database.
     */
    private CveDB cve;

    /**
     * The URL to perform a search of the NVD CVE data at NIST.
     */
    public static final String NVD_SEARCH_URL = &quot;https://web.nvd.nist.gov/view/vuln/search-results?adv_search=true&amp;cves=on&amp;cpe_version=%s&quot;;

    /**
     * Returns the name of this analyzer.
     *
     * @return the name of this analyzer.
     */
    @Override
    public String getName() {
<span class="fc" id="L116">        return &quot;CPE Analyzer&quot;;</span>
    }

    /**
     * Returns the analysis phase that this analyzer should run in.
     *
     * @return the analysis phase that this analyzer should run in.
     */
    @Override
    public AnalysisPhase getAnalysisPhase() {
<span class="fc" id="L126">        return AnalysisPhase.IDENTIFIER_ANALYSIS;</span>
    }

    /**
     * The default is to support parallel processing.
     *
     * @return false
     */
    @Override
    public boolean supportsParallelProcessing() {
<span class="fc" id="L136">        return false;</span>
    }

    /**
     * Creates the CPE Lucene Index.
     *
     * @throws InitializationException is thrown if there is an issue opening
     * the index.
     */
    @Override
    public void initializeAnalyzer() throws InitializationException {
        try {
<span class="fc" id="L148">            this.open();</span>
<span class="nc" id="L149">        } catch (IOException ex) {</span>
<span class="nc" id="L150">            LOGGER.debug(&quot;Exception initializing the Lucene Index&quot;, ex);</span>
<span class="nc" id="L151">            throw new InitializationException(&quot;An exception occurred initializing the Lucene Index&quot;, ex);</span>
<span class="nc" id="L152">        } catch (DatabaseException ex) {</span>
<span class="nc" id="L153">            LOGGER.debug(&quot;Exception accessing the database&quot;, ex);</span>
<span class="nc" id="L154">            throw new InitializationException(&quot;An exception occurred accessing the database&quot;, ex);</span>
<span class="fc" id="L155">        }</span>
<span class="fc" id="L156">    }</span>

    /**
     * Opens the data source.
     *
     * @throws IOException when the Lucene directory to be queried does not
     * exist or is corrupt.
     * @throws DatabaseException when the database throws an exception. This
     * usually occurs when the database is in use by another process.
     */
    public void open() throws IOException, DatabaseException {
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">        if (!isOpen()) {</span>
<span class="fc" id="L168">            cve = CveDB.getInstance();</span>
<span class="fc" id="L169">            cpe = CpeMemoryIndex.getInstance();</span>
            try {
<span class="fc" id="L171">                final long creationStart = System.currentTimeMillis();</span>
<span class="fc" id="L172">                cpe.open(cve);</span>
<span class="fc" id="L173">                final long creationSeconds = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - creationStart);</span>
<span class="fc" id="L174">                LOGGER.info(&quot;Created CPE Index ({} seconds)&quot;, creationSeconds);</span>
<span class="nc" id="L175">            } catch (IndexException ex) {</span>
<span class="nc" id="L176">                LOGGER.debug(&quot;IndexException&quot;, ex);</span>
<span class="nc" id="L177">                throw new DatabaseException(ex);</span>
<span class="fc" id="L178">            }</span>
        }
<span class="fc" id="L180">    }</span>

    /**
     * Closes the data sources.
     */
    @Override
    public void closeAnalyzer() {
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">        if (cve != null) {</span>
<span class="fc" id="L188">            cve.close();</span>
<span class="fc" id="L189">            cve = null;</span>
        }
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">        if (cpe != null) {</span>
<span class="fc" id="L192">            cpe.close();</span>
<span class="fc" id="L193">            cpe = null;</span>
        }
<span class="fc" id="L195">    }</span>

    /**
     * Returns whether or not the analyzer is open.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the analyzer is open
     */
    public boolean isOpen() {
<span class="pc bpc" id="L203" title="3 of 4 branches missed.">        return cpe != null &amp;&amp; cpe.isOpen();</span>
    }

    /**
     * Searches the data store of CPE entries, trying to identify the CPE for
     * the given dependency based on the evidence contained within. The
     * dependency passed in is updated with any identified CPE values.
     *
     * @param dependency the dependency to search for CPE entries on.
     * @throws CorruptIndexException is thrown when the Lucene index is corrupt.
     * @throws IOException is thrown when an IOException occurs.
     * @throws ParseException is thrown when the Lucene query cannot be parsed.
     */
    protected void determineCPE(Dependency dependency) throws CorruptIndexException, IOException, ParseException {
<span class="fc" id="L217">        String vendors = &quot;&quot;;</span>
<span class="fc" id="L218">        String products = &quot;&quot;;</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">        for (Confidence confidence : Confidence.values()) {</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">            if (dependency.getVendorEvidence().contains(confidence)) {</span>
<span class="fc" id="L221">                vendors = addEvidenceWithoutDuplicateTerms(vendors, dependency.getVendorEvidence(), confidence);</span>
<span class="fc" id="L222">                LOGGER.debug(&quot;vendor search: {}&quot;, vendors);</span>
            }
<span class="fc bfc" id="L224" title="All 2 branches covered.">            if (dependency.getProductEvidence().contains(confidence)) {</span>
<span class="fc" id="L225">                products = addEvidenceWithoutDuplicateTerms(products, dependency.getProductEvidence(), confidence);</span>
<span class="fc" id="L226">                LOGGER.debug(&quot;product search: {}&quot;, products);</span>
            }
<span class="pc bpc" id="L228" title="1 of 4 branches missed.">            if (!vendors.isEmpty() &amp;&amp; !products.isEmpty()) {</span>
<span class="fc" id="L229">                final List&lt;IndexEntry&gt; entries = searchCPE(vendors, products, dependency.getVendorEvidence().getWeighting(),</span>
                        dependency.getProductEvidence().getWeighting());
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">                if (entries == null) {</span>
<span class="nc" id="L232">                    continue;</span>
                }
<span class="fc" id="L234">                boolean identifierAdded = false;</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">                for (IndexEntry e : entries) {</span>
<span class="fc" id="L236">                    LOGGER.debug(&quot;Verifying entry: {}&quot;, e);</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">                    if (verifyEntry(e, dependency)) {</span>
<span class="fc" id="L238">                        final String vendor = e.getVendor();</span>
<span class="fc" id="L239">                        final String product = e.getProduct();</span>
<span class="fc" id="L240">                        LOGGER.debug(&quot;identified vendor/product: {}/{}&quot;, vendor, product);</span>
<span class="fc" id="L241">                        identifierAdded |= determineIdentifiers(dependency, vendor, product, confidence);</span>
                    }
<span class="fc" id="L243">                }</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">                if (identifierAdded) {</span>
<span class="fc" id="L245">                    break;</span>
                }
            }
        }
<span class="fc" id="L249">    }</span>

    /**
     * Returns the text created by concatenating the text and the values from
     * the EvidenceCollection (filtered for a specific confidence). This
     * attempts to prevent duplicate terms from being added.&lt;br/&lt;br/&gt; Note, if
     * the evidence is longer then 200 characters it will be truncated.
     *
     * @param text the base text.
     * @param ec an EvidenceCollection
     * @param confidenceFilter a Confidence level to filter the evidence by.
     * @return the new evidence text
     */
    private String addEvidenceWithoutDuplicateTerms(final String text, final EvidenceCollection ec, Confidence confidenceFilter) {
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">        final String txt = (text == null) ? &quot;&quot; : text;</span>
<span class="fc" id="L264">        final StringBuilder sb = new StringBuilder(txt.length() + (20 * ec.size()));</span>
<span class="fc" id="L265">        sb.append(' ').append(txt).append(' ');</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">        for (Evidence e : ec.iterator(confidenceFilter)) {</span>
<span class="fc" id="L267">            String value = e.getValue();</span>

            //hack to get around the fact that lucene does a really good job of recognizing domains and not
            // splitting them. TODO - put together a better lucene analyzer specific to the domain.
<span class="fc bfc" id="L271" title="All 2 branches covered.">            if (value.startsWith(&quot;http://&quot;)) {</span>
<span class="fc" id="L272">                value = value.substring(7).replaceAll(&quot;\\.&quot;, &quot; &quot;);</span>
            }
<span class="fc bfc" id="L274" title="All 2 branches covered.">            if (value.startsWith(&quot;https://&quot;)) {</span>
<span class="fc" id="L275">                value = value.substring(8).replaceAll(&quot;\\.&quot;, &quot; &quot;);</span>
            }
<span class="fc bfc" id="L277" title="All 2 branches covered.">            if (sb.indexOf(&quot; &quot; + value + &quot; &quot;) &lt; 0) {</span>
<span class="fc" id="L278">                sb.append(value).append(' ');</span>
            }
<span class="fc" id="L280">        }</span>
<span class="fc" id="L281">        return sb.toString().trim();</span>
    }

    /**
     * &lt;p&gt;
     * Searches the Lucene CPE index to identify possible CPE entries associated
     * with the supplied vendor, product, and version.&lt;/p&gt;
     *
     * &lt;p&gt;
     * If either the vendorWeightings or productWeightings lists have been
     * populated this data is used to add weighting factors to the search.&lt;/p&gt;
     *
     * @param vendor the text used to search the vendor field
     * @param product the text used to search the product field
     * @param vendorWeightings a list of strings to use to add weighting factors
     * to the vendor field
     * @param productWeightings Adds a list of strings that will be used to add
     * weighting factors to the product search
     * @return a list of possible CPE values
     */
    protected List&lt;IndexEntry&gt; searchCPE(String vendor, String product,
            Set&lt;String&gt; vendorWeightings, Set&lt;String&gt; productWeightings) {

<span class="fc" id="L304">        final List&lt;IndexEntry&gt; ret = new ArrayList&lt;&gt;(MAX_QUERY_RESULTS);</span>

<span class="fc" id="L306">        final String searchString = buildSearch(vendor, product, vendorWeightings, productWeightings);</span>
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">        if (searchString == null) {</span>
<span class="nc" id="L308">            return ret;</span>
        }
        try {
<span class="fc" id="L311">            final TopDocs docs = cpe.search(searchString, MAX_QUERY_RESULTS);</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">            for (ScoreDoc d : docs.scoreDocs) {</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">                if (d.score &gt;= 0.08) {</span>
<span class="fc" id="L314">                    final Document doc = cpe.getDocument(d.doc);</span>
<span class="fc" id="L315">                    final IndexEntry entry = new IndexEntry();</span>
<span class="fc" id="L316">                    entry.setVendor(doc.get(Fields.VENDOR));</span>
<span class="fc" id="L317">                    entry.setProduct(doc.get(Fields.PRODUCT));</span>
<span class="fc" id="L318">                    entry.setSearchScore(d.score);</span>
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">                    if (!ret.contains(entry)) {</span>
<span class="fc" id="L320">                        ret.add(entry);</span>
                    }
                }
            }
<span class="fc" id="L324">            return ret;</span>
<span class="nc" id="L325">        } catch (ParseException ex) {</span>
<span class="nc" id="L326">            LOGGER.warn(&quot;An error occurred querying the CPE data. See the log for more details.&quot;);</span>
<span class="nc" id="L327">            LOGGER.info(&quot;Unable to parse: {}&quot;, searchString, ex);</span>
<span class="nc" id="L328">        } catch (IOException ex) {</span>
<span class="nc" id="L329">            LOGGER.warn(&quot;An error occurred reading CPE data. See the log for more details.&quot;);</span>
<span class="nc" id="L330">            LOGGER.info(&quot;IO Error with search string: {}&quot;, searchString, ex);</span>
<span class="nc" id="L331">        }</span>
<span class="nc" id="L332">        return null;</span>
    }

    /**
     * &lt;p&gt;
     * Builds a Lucene search string by properly escaping data and constructing
     * a valid search query.&lt;/p&gt;
     *
     * &lt;p&gt;
     * If either the possibleVendor or possibleProducts lists have been
     * populated this data is used to add weighting factors to the search string
     * generated.&lt;/p&gt;
     *
     * @param vendor text to search the vendor field
     * @param product text to search the product field
     * @param vendorWeighting a list of strings to apply to the vendor to boost
     * the terms weight
     * @param productWeightings a list of strings to apply to the product to
     * boost the terms weight
     * @return the Lucene query
     */
    protected String buildSearch(String vendor, String product,
            Set&lt;String&gt; vendorWeighting, Set&lt;String&gt; productWeightings) {
<span class="fc" id="L355">        final String v = vendor; //.replaceAll(&quot;[^\\w\\d]&quot;, &quot; &quot;);</span>
<span class="fc" id="L356">        final String p = product; //.replaceAll(&quot;[^\\w\\d]&quot;, &quot; &quot;);</span>
<span class="fc" id="L357">        final StringBuilder sb = new StringBuilder(v.length() + p.length()</span>
                + Fields.PRODUCT.length() + Fields.VENDOR.length() + STRING_BUILDER_BUFFER);

<span class="pc bpc" id="L360" title="1 of 2 branches missed.">        if (!appendWeightedSearch(sb, Fields.PRODUCT, p, productWeightings)) {</span>
<span class="nc" id="L361">            return null;</span>
        }
<span class="fc" id="L363">        sb.append(&quot; AND &quot;);</span>
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">        if (!appendWeightedSearch(sb, Fields.VENDOR, v, vendorWeighting)) {</span>
<span class="nc" id="L365">            return null;</span>
        }
<span class="fc" id="L367">        return sb.toString();</span>
    }

    /**
     * This method constructs a Lucene query for a given field. The searchText
     * is split into separate words and if the word is within the list of
     * weighted words then an additional weighting is applied to the term as it
     * is appended into the query.
     *
     * @param sb a StringBuilder that the query text will be appended to.
     * @param field the field within the Lucene index that the query is
     * searching.
     * @param searchText text used to construct the query.
     * @param weightedText a list of terms that will be considered higher
     * importance when searching.
     * @return if the append was successful.
     */
    private boolean appendWeightedSearch(StringBuilder sb, String field, String searchText, Set&lt;String&gt; weightedText) {
<span class="fc" id="L385">        sb.append(' ').append(field).append(&quot;:( &quot;);</span>

<span class="fc" id="L387">        final String cleanText = cleanseText(searchText);</span>

<span class="pc bpc" id="L389" title="1 of 2 branches missed.">        if (cleanText.isEmpty()) {</span>
<span class="nc" id="L390">            return false;</span>
        }

<span class="fc bfc" id="L393" title="All 4 branches covered.">        if (weightedText == null || weightedText.isEmpty()) {</span>
<span class="fc" id="L394">            LuceneUtils.appendEscapedLuceneQuery(sb, cleanText);</span>
        } else {
<span class="fc" id="L396">            final StringTokenizer tokens = new StringTokenizer(cleanText);</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">            while (tokens.hasMoreElements()) {</span>
<span class="fc" id="L398">                final String word = tokens.nextToken();</span>
<span class="fc" id="L399">                StringBuilder temp = null;</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">                for (String weighted : weightedText) {</span>
<span class="fc" id="L401">                    final String weightedStr = cleanseText(weighted);</span>
<span class="fc bfc" id="L402" title="All 2 branches covered.">                    if (equalsIgnoreCaseAndNonAlpha(word, weightedStr)) {</span>
<span class="fc" id="L403">                        temp = new StringBuilder(word.length() + 2);</span>
<span class="fc" id="L404">                        LuceneUtils.appendEscapedLuceneQuery(temp, word);</span>
<span class="fc" id="L405">                        temp.append(WEIGHTING_BOOST);</span>
<span class="fc bfc" id="L406" title="All 2 branches covered.">                        if (!word.equalsIgnoreCase(weightedStr)) {</span>
<span class="fc" id="L407">                            temp.append(' ');</span>
<span class="fc" id="L408">                            LuceneUtils.appendEscapedLuceneQuery(temp, weightedStr);</span>
<span class="fc" id="L409">                            temp.append(WEIGHTING_BOOST);</span>
                        }
                        break;
                    }
<span class="fc" id="L413">                }</span>
<span class="fc" id="L414">                sb.append(' ');</span>
<span class="fc bfc" id="L415" title="All 2 branches covered.">                if (temp == null) {</span>
<span class="fc" id="L416">                    LuceneUtils.appendEscapedLuceneQuery(sb, word);</span>
                } else {
<span class="fc" id="L418">                    sb.append(temp);</span>
                }
<span class="fc" id="L420">            }</span>
        }
<span class="fc" id="L422">        sb.append(&quot; ) &quot;);</span>
<span class="fc" id="L423">        return true;</span>
    }

    /**
     * Removes characters from the input text that are not used within the CPE
     * index.
     *
     * @param text is the text to remove the characters from.
     * @return the text having removed some characters.
     */
    private String cleanseText(String text) {
<span class="fc" id="L434">        return text.replaceAll(CLEANSE_CHARACTER_RX, &quot; &quot;);</span>
    }

    /**
     * Compares two strings after lower casing them and removing the non-alpha
     * characters.
     *
     * @param l string one to compare.
     * @param r string two to compare.
     * @return whether or not the two strings are similar.
     */
    private boolean equalsIgnoreCaseAndNonAlpha(String l, String r) {
<span class="pc bpc" id="L446" title="2 of 4 branches missed.">        if (l == null || r == null) {</span>
<span class="nc" id="L447">            return false;</span>
        }

<span class="fc" id="L450">        final String left = l.replaceAll(CLEANSE_NONALPHA_RX, &quot;&quot;);</span>
<span class="fc" id="L451">        final String right = r.replaceAll(CLEANSE_NONALPHA_RX, &quot;&quot;);</span>
<span class="fc" id="L452">        return left.equalsIgnoreCase(right);</span>
    }

    /**
     * Ensures that the CPE Identified matches the dependency. This validates
     * that the product, vendor, and version information for the CPE are
     * contained within the dependencies evidence.
     *
     * @param entry a CPE entry.
     * @param dependency the dependency that the CPE entries could be for.
     * @return whether or not the entry is valid.
     */
    private boolean verifyEntry(final IndexEntry entry, final Dependency dependency) {
<span class="fc" id="L465">        boolean isValid = false;</span>

        //TODO - does this nullify some of the fuzzy matching that happens in the lucene search?
        // for instance CPE some-component and in the evidence we have SomeComponent.
<span class="fc bfc" id="L469" title="All 4 branches covered.">        if (collectionContainsString(dependency.getProductEvidence(), entry.getProduct())</span>
                &amp;&amp; collectionContainsString(dependency.getVendorEvidence(), entry.getVendor())) {
            //&amp;&amp; collectionContainsVersion(dependency.getVersionEvidence(), entry.getVersion())
<span class="fc" id="L472">            isValid = true;</span>
        }
<span class="fc" id="L474">        return isValid;</span>
    }

    /**
     * Used to determine if the EvidenceCollection contains a specific string.
     *
     * @param ec an EvidenceCollection
     * @param text the text to search for
     * @return whether or not the EvidenceCollection contains the string
     */
    private boolean collectionContainsString(EvidenceCollection ec, String text) {
        //TODO - likely need to change the split... not sure if this will work for CPE with special chars
<span class="pc bpc" id="L486" title="1 of 2 branches missed.">        if (text == null) {</span>
<span class="nc" id="L487">            return false;</span>
        }
<span class="fc" id="L489">        final String[] words = text.split(&quot;[\\s_-]&quot;);</span>
<span class="fc" id="L490">        final List&lt;String&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L491">        String tempWord = null;</span>
<span class="fc" id="L492">        CharArraySet stopWords = SearchFieldAnalyzer.getStopWords();</span>
<span class="fc bfc" id="L493" title="All 2 branches covered.">        for (String word : words) {</span>
<span class="fc bfc" id="L494" title="All 2 branches covered.">            if (stopWords.contains(word)) {</span>
<span class="fc" id="L495">                continue;</span>
            }
            /*
             single letter words should be concatenated with the next word.
             so { &quot;m&quot;, &quot;core&quot;, &quot;sample&quot; } -&gt; { &quot;mcore&quot;, &quot;sample&quot; }
             */
<span class="fc bfc" id="L501" title="All 2 branches covered.">            if (tempWord != null) {</span>
<span class="fc" id="L502">                list.add(tempWord + word);</span>
<span class="fc" id="L503">                tempWord = null;</span>
<span class="fc bfc" id="L504" title="All 2 branches covered.">            } else if (word.length() &lt;= 2) {</span>
<span class="fc" id="L505">                tempWord = word;</span>
            } else {
<span class="fc" id="L507">                list.add(word);</span>
            }
        }
<span class="fc bfc" id="L510" title="All 2 branches covered.">        if (tempWord != null) {</span>
<span class="fc bfc" id="L511" title="All 2 branches covered.">            if (!list.isEmpty()) {</span>
<span class="fc" id="L512">                final String tmp = list.get(list.size() - 1) + tempWord;</span>
<span class="fc" id="L513">                list.add(tmp);</span>
<span class="fc" id="L514">            } else {</span>
<span class="fc" id="L515">                list.add(tempWord);</span>
            }
        }
<span class="pc bpc" id="L518" title="1 of 2 branches missed.">        if (list.isEmpty()) {</span>
<span class="nc" id="L519">            return false;</span>
        }
<span class="fc" id="L521">        boolean contains = true;</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">        for (String word : list) {</span>
<span class="fc" id="L523">            contains &amp;= ec.containsUsedString(word);</span>
<span class="fc" id="L524">        }</span>
<span class="fc" id="L525">        return contains;</span>
    }

    /**
     * Analyzes a dependency and attempts to determine if there are any CPE
     * identifiers for this dependency.
     *
     * @param dependency The Dependency to analyze.
     * @param engine The analysis engine
     * @throws AnalysisException is thrown if there is an issue analyzing the
     * dependency.
     */
    @Override
    protected synchronized void analyzeDependency(Dependency dependency, Engine engine) throws AnalysisException {
        try {
<span class="fc" id="L540">            determineCPE(dependency);</span>
<span class="nc" id="L541">        } catch (CorruptIndexException ex) {</span>
<span class="nc" id="L542">            throw new AnalysisException(&quot;CPE Index is corrupt.&quot;, ex);</span>
<span class="nc" id="L543">        } catch (IOException ex) {</span>
<span class="nc" id="L544">            throw new AnalysisException(&quot;Failure opening the CPE Index.&quot;, ex);</span>
<span class="nc" id="L545">        } catch (ParseException ex) {</span>
<span class="nc" id="L546">            throw new AnalysisException(&quot;Unable to parse the generated Lucene query for this dependency.&quot;, ex);</span>
<span class="fc" id="L547">        }</span>
<span class="fc" id="L548">    }</span>

    /**
     * Retrieves a list of CPE values from the CveDB based on the vendor and
     * product passed in. The list is then validated to find only CPEs that are
     * valid for the given dependency. It is possible that the CPE identified is
     * a best effort &quot;guess&quot; based on the vendor, product, and version
     * information.
     *
     * @param dependency the Dependency being analyzed
     * @param vendor the vendor for the CPE being analyzed
     * @param product the product for the CPE being analyzed
     * @param currentConfidence the current confidence being used during
     * analysis
     * @return &lt;code&gt;true&lt;/code&gt; if an identifier was added to the dependency;
     * otherwise &lt;code&gt;false&lt;/code&gt;
     * @throws UnsupportedEncodingException is thrown if UTF-8 is not supported
     */
    protected boolean determineIdentifiers(Dependency dependency, String vendor, String product,
            Confidence currentConfidence) throws UnsupportedEncodingException {
<span class="fc" id="L568">        final Set&lt;VulnerableSoftware&gt; cpes = cve.getCPEs(vendor, product);</span>
<span class="pc bpc" id="L569" title="1 of 2 branches missed.">        if (cpes.isEmpty()) {</span>
<span class="nc" id="L570">            return false;</span>
        }
<span class="fc" id="L572">        DependencyVersion bestGuess = new DependencyVersion(&quot;-&quot;);</span>
<span class="fc" id="L573">        Confidence bestGuessConf = null;</span>
<span class="fc" id="L574">        boolean hasBroadMatch = false;</span>
<span class="fc" id="L575">        final List&lt;IdentifierMatch&gt; collected = new ArrayList&lt;&gt;();</span>

        //TODO the following algorithm incorrectly identifies things as a lower version
        // if there lower confidence evidence when the current (highest) version number
        // is newer then anything in the NVD.
<span class="fc bfc" id="L580" title="All 2 branches covered.">        for (Confidence conf : Confidence.values()) {</span>
<span class="fc bfc" id="L581" title="All 2 branches covered.">            for (Evidence evidence : dependency.getVersionEvidence().iterator(conf)) {</span>
<span class="fc" id="L582">                final DependencyVersion evVer = DependencyVersionUtil.parseVersion(evidence.getValue());</span>
<span class="fc bfc" id="L583" title="All 2 branches covered.">                if (evVer == null) {</span>
<span class="fc" id="L584">                    continue;</span>
                }
<span class="fc bfc" id="L586" title="All 2 branches covered.">                for (VulnerableSoftware vs : cpes) {</span>
                    DependencyVersion dbVer;
<span class="pc bpc" id="L588" title="1 of 4 branches missed.">                    if (vs.getUpdate() != null &amp;&amp; !vs.getUpdate().isEmpty()) {</span>
<span class="fc" id="L589">                        dbVer = DependencyVersionUtil.parseVersion(vs.getVersion() + '.' + vs.getUpdate());</span>
                    } else {
<span class="fc" id="L591">                        dbVer = DependencyVersionUtil.parseVersion(vs.getVersion());</span>
                    }
<span class="fc bfc" id="L593" title="All 2 branches covered.">                    if (dbVer == null) { //special case, no version specified - everything is vulnerable</span>
<span class="fc" id="L594">                        hasBroadMatch = true;</span>
<span class="fc" id="L595">                        final String url = String.format(NVD_SEARCH_URL, URLEncoder.encode(vs.getName(), &quot;UTF-8&quot;));</span>
<span class="fc" id="L596">                        final IdentifierMatch match = new IdentifierMatch(&quot;cpe&quot;, vs.getName(), url, IdentifierConfidence.BROAD_MATCH, conf);</span>
<span class="fc" id="L597">                        collected.add(match);</span>
<span class="fc bfc" id="L598" title="All 2 branches covered.">                    } else if (evVer.equals(dbVer)) { //yeah! exact match</span>
<span class="fc" id="L599">                        final String url = String.format(NVD_SEARCH_URL, URLEncoder.encode(vs.getName(), &quot;UTF-8&quot;));</span>
<span class="fc" id="L600">                        final IdentifierMatch match = new IdentifierMatch(&quot;cpe&quot;, vs.getName(), url, IdentifierConfidence.EXACT_MATCH, conf);</span>
<span class="fc" id="L601">                        collected.add(match);</span>

                        //TODO the following isn't quite right is it? need to think about this guessing game a bit more.
<span class="fc bfc" id="L604" title="All 4 branches covered.">                    } else if (evVer.getVersionParts().size() &lt;= dbVer.getVersionParts().size()</span>
                            &amp;&amp; evVer.matchesAtLeastThreeLevels(dbVer)) {
<span class="pc bpc" id="L606" title="1 of 4 branches missed.">                        if (bestGuessConf == null || bestGuessConf.compareTo(conf) &gt; 0) {</span>
<span class="pc bpc" id="L607" title="1 of 2 branches missed.">                            if (bestGuess.getVersionParts().size() &lt; dbVer.getVersionParts().size()) {</span>
<span class="fc" id="L608">                                bestGuess = dbVer;</span>
<span class="fc" id="L609">                                bestGuessConf = conf;</span>
                            }
                        }
                    }
<span class="fc" id="L613">                }</span>
<span class="pc bpc" id="L614" title="1 of 6 branches missed.">                if ((bestGuessConf == null || bestGuessConf.compareTo(conf) &gt; 0)</span>
                        &amp;&amp; bestGuess.getVersionParts().size() &lt; evVer.getVersionParts().size()) {
<span class="fc" id="L616">                    bestGuess = evVer;</span>
<span class="fc" id="L617">                    bestGuessConf = conf;</span>
                }
<span class="fc" id="L619">            }</span>
        }
<span class="fc" id="L621">        final String cpeName = String.format(&quot;cpe:/a:%s:%s:%s&quot;, vendor, product, bestGuess.toString());</span>
<span class="fc" id="L622">        String url = null;</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">        if (hasBroadMatch) { //if we have a broad match we can add the URL to the best guess.</span>
<span class="fc" id="L624">            final String cpeUrlName = String.format(&quot;cpe:/a:%s:%s&quot;, vendor, product);</span>
<span class="fc" id="L625">            url = String.format(NVD_SEARCH_URL, URLEncoder.encode(cpeUrlName, &quot;UTF-8&quot;));</span>
        }
<span class="fc bfc" id="L627" title="All 2 branches covered.">        if (bestGuessConf</span>
                == null) {
<span class="fc" id="L629">            bestGuessConf = Confidence.LOW;</span>
        }
<span class="fc" id="L631">        final IdentifierMatch match = new IdentifierMatch(&quot;cpe&quot;, cpeName, url, IdentifierConfidence.BEST_GUESS, bestGuessConf);</span>

<span class="fc" id="L633">        collected.add(match);</span>

<span class="fc" id="L635">        Collections.sort(collected);</span>
<span class="fc" id="L636">        final IdentifierConfidence bestIdentifierQuality = collected.get(0).getConfidence();</span>
<span class="fc" id="L637">        final Confidence bestEvidenceQuality = collected.get(0).getEvidenceConfidence();</span>
<span class="fc" id="L638">        boolean identifierAdded = false;</span>
<span class="fc bfc" id="L639" title="All 2 branches covered.">        for (IdentifierMatch m : collected) {</span>
<span class="fc bfc" id="L640" title="All 4 branches covered.">            if (bestIdentifierQuality.equals(m.getConfidence())</span>
                    &amp;&amp; bestEvidenceQuality.equals(m.getEvidenceConfidence())) {
<span class="fc" id="L642">                final Identifier i = m.getIdentifier();</span>
<span class="fc bfc" id="L643" title="All 2 branches covered.">                if (bestIdentifierQuality == IdentifierConfidence.BEST_GUESS) {</span>
<span class="fc" id="L644">                    i.setConfidence(Confidence.LOW);</span>
                } else {
<span class="fc" id="L646">                    i.setConfidence(bestEvidenceQuality);</span>
                }
<span class="fc" id="L648">                dependency.addIdentifier(i);</span>
<span class="fc" id="L649">                identifierAdded = true;</span>
            }
<span class="fc" id="L651">        }</span>
<span class="fc" id="L652">        return identifierAdded;</span>
    }

    /**
     * &lt;p&gt;
     * Returns the setting key to determine if the analyzer is enabled.&lt;/p&gt;
     *
     * @return the key for the analyzer's enabled property
     */
    @Override
    protected String getAnalyzerEnabledSettingKey() {
<span class="fc" id="L663">        return Settings.KEYS.ANALYZER_CPE_ENABLED;</span>

    }

    /**
     * The confidence whether the identifier is an exact match, or a best guess.
     */
<span class="pc" id="L670">    private enum IdentifierConfidence {</span>

        /**
         * An exact match for the CPE.
         */
<span class="fc" id="L675">        EXACT_MATCH,</span>
        /**
         * A best guess for the CPE.
         */
<span class="fc" id="L679">        BEST_GUESS,</span>
        /**
         * The entire vendor/product group must be added (without a guess at
         * version) because there is a CVE with a VS that only specifies
         * vendor/product.
         */
<span class="fc" id="L685">        BROAD_MATCH</span>
    }

    /**
     * A simple object to hold an identifier and carry information about the
     * confidence in the identifier.
     */
<span class="fc" id="L692">    private static class IdentifierMatch implements Comparable&lt;IdentifierMatch&gt; {</span>

        /**
         * The confidence in the evidence used to identify this match.
         */
        private Confidence evidenceConfidence;
        /**
         * The confidence whether this is an exact match, or a best guess.
         */
        private IdentifierConfidence confidence;
        /**
         * The CPE identifier.
         */
        private Identifier identifier;

        /**
         * Constructs an IdentifierMatch.
         *
         * @param type the type of identifier (such as CPE)
         * @param value the value of the identifier
         * @param url the URL of the identifier
         * @param identifierConfidence the confidence in the identifier: best
         * guess or exact match
         * @param evidenceConfidence the confidence of the evidence used to find
         * the identifier
         */
<span class="fc" id="L718">        IdentifierMatch(String type, String value, String url, IdentifierConfidence identifierConfidence, Confidence evidenceConfidence) {</span>
<span class="fc" id="L719">            this.identifier = new Identifier(type, value, url);</span>
<span class="fc" id="L720">            this.confidence = identifierConfidence;</span>
<span class="fc" id="L721">            this.evidenceConfidence = evidenceConfidence;</span>
<span class="fc" id="L722">        }</span>

        //&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Property implementations: evidenceConfidence, confidence, identifier&quot;&gt;
        /**
         * Get the value of evidenceConfidence
         *
         * @return the value of evidenceConfidence
         */
        public Confidence getEvidenceConfidence() {
<span class="fc" id="L731">            return evidenceConfidence;</span>
        }

        /**
         * Set the value of evidenceConfidence
         *
         * @param evidenceConfidence new value of evidenceConfidence
         */
        public void setEvidenceConfidence(Confidence evidenceConfidence) {
<span class="nc" id="L740">            this.evidenceConfidence = evidenceConfidence;</span>
<span class="nc" id="L741">        }</span>

        /**
         * Get the value of confidence.
         *
         * @return the value of confidence
         */
        public IdentifierConfidence getConfidence() {
<span class="fc" id="L749">            return confidence;</span>
        }

        /**
         * Set the value of confidence.
         *
         * @param confidence new value of confidence
         */
        public void setConfidence(IdentifierConfidence confidence) {
<span class="nc" id="L758">            this.confidence = confidence;</span>
<span class="nc" id="L759">        }</span>

        /**
         * Get the value of identifier.
         *
         * @return the value of identifier
         */
        public Identifier getIdentifier() {
<span class="fc" id="L767">            return identifier;</span>
        }

        /**
         * Set the value of identifier.
         *
         * @param identifier new value of identifier
         */
        public void setIdentifier(Identifier identifier) {
<span class="nc" id="L776">            this.identifier = identifier;</span>
<span class="nc" id="L777">        }</span>
        //&lt;/editor-fold&gt;
        //&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Standard implementations of toString, hashCode, and equals&quot;&gt;

        /**
         * Standard toString() implementation.
         *
         * @return the string representation of the object
         */
        @Override
        public String toString() {
<span class="nc" id="L788">            return &quot;IdentifierMatch{&quot; + &quot;evidenceConfidence=&quot; + evidenceConfidence</span>
                    + &quot;, confidence=&quot; + confidence + &quot;, identifier=&quot; + identifier + '}';
        }

        /**
         * Standard hashCode() implementation.
         *
         * @return the hashCode
         */
        @Override
        public int hashCode() {
<span class="nc" id="L799">            int hash = 5;</span>
<span class="nc bnc" id="L800" title="All 2 branches missed.">            hash = 97 * hash + (this.evidenceConfidence != null ? this.evidenceConfidence.hashCode() : 0);</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">            hash = 97 * hash + (this.confidence != null ? this.confidence.hashCode() : 0);</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">            hash = 97 * hash + (this.identifier != null ? this.identifier.hashCode() : 0);</span>
<span class="nc" id="L803">            return hash;</span>
        }

        /**
         * Standard equals implementation.
         *
         * @param obj the object to compare
         * @return true if the objects are equal, otherwise false
         */
        @Override
        public boolean equals(Object obj) {
<span class="nc bnc" id="L814" title="All 2 branches missed.">            if (obj == null) {</span>
<span class="nc" id="L815">                return false;</span>
            }
<span class="nc bnc" id="L817" title="All 2 branches missed.">            if (getClass() != obj.getClass()) {</span>
<span class="nc" id="L818">                return false;</span>
            }
<span class="nc" id="L820">            final IdentifierMatch other = (IdentifierMatch) obj;</span>
<span class="nc bnc" id="L821" title="All 2 branches missed.">            if (this.evidenceConfidence != other.evidenceConfidence) {</span>
<span class="nc" id="L822">                return false;</span>
            }
<span class="nc bnc" id="L824" title="All 2 branches missed.">            if (this.confidence != other.confidence) {</span>
<span class="nc" id="L825">                return false;</span>
            }
<span class="nc bnc" id="L827" title="All 6 branches missed.">            return !(this.identifier != other.identifier &amp;&amp; (this.identifier == null || !this.identifier.equals(other.identifier)));</span>
        }
        //&lt;/editor-fold&gt;

        /**
         * Standard implementation of compareTo that compares identifier
         * confidence, evidence confidence, and then the identifier.
         *
         * @param o the IdentifierMatch to compare to
         * @return the natural ordering of IdentifierMatch
         */
        @Override
        public int compareTo(IdentifierMatch o) {
<span class="fc" id="L840">            return new CompareToBuilder()</span>
                    .append(confidence, o.confidence)
                    .append(evidenceConfidence, o.evidenceConfidence)
                    .append(identifier, o.identifier)
                    .toComparison();
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>